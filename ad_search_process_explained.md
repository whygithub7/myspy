# Технический разбор процесса поиска рекламы в Facebook Ads MCP

Этот документ подробно описывает технический процесс выполнения команды поиска рекламы, от ввода запроса пользователем до сохранения результатов на диск.

---

### ЭТАП 1: Инициализация и Передача команды
**(User -> IDE -> manual_mcp.py)**

**1. Ввод запроса**
Пользователь вводит в чат IDE: *"найди рекламу по запросу 'prostate'"*.
IDE анализирует текст и идентифицирует необходимость вызова инструмента `search_ads_final` с параметром `query="prostate"`.

**2. Формирование RPC-запроса**
IDE упаковывает команду в строгий формат **JSON-RPC**.

> **ТЕХНИЧЕСКИЙ ТЕРМИН: RPC (Remote Procedure Call)**
> *Удаленный вызов процедуры.* Стандарт протокола, по которому одна программа (IDE) просит другую (Python-скрипт) выполнить конкретную функцию. Запрос — это JSON-объект с полями: `method` (имя функции), `params` (аргументы) и `id` (уникальный идентификатор запроса).

**3. Передача данных в STDIN**
IDE отправляет этот JSON-RPC объект в **STDIN** запущенного процесса `python manual_mcp.py`.

> **ТЕХНИЧЕСКИЙ ТЕРМИН: STDIN (Standard Input)**
> *Стандартный поток ввода.* Канал передачи данных внутрь запущенной программы. IDE пишет байты напрямую в этот поток, эмулируя ввод данных.

---

### ЭТАП 2: Прием и Маршрутизация
**(Файл: manual_mcp.py)**

**4. Чтение потока**
Скрипт выполняет `sys.stdin.buffer.readline()`. Он физически считывает набор байтов, пришедших от IDE через STDIN.

**5. Десериализация**
Скрипт выполняет `json.loads(line)`.

> **ТЕХНИЧЕСКИЙ ТЕРМИН: Deserialization (Десериализация)**
> Процесс преобразования строки текста (JSON) обратно в структуру данных языка программирования (словарь Python `dict`), пригодную для обработки кодом.

**6. Маршрутизация**
Скрипт анализирует словарь:
*   Проверяет метод: `"method": "tools/call"`.
*   Извлекает имя инструмента: `"name": "search_ads_final"`.
*   Извлекает аргументы `args`: `{"query": "prostate", "limit": 20, ...}`.
*   Вызывает локальную функцию-диспетчер `call_tool(name, args)`.

**7. Диспетчеризация**
Внутри `call_tool` скрипт находит совпадение `if name == "search_ads_final"` и вызывает целевую функцию из библиотеки: `mcp_library.search_facebook_ads(**arguments)`.
*Управление передается в файл `mcp_library.py`.*

---

### ЭТАП 3: Оркестрация поиска
**(Файл: mcp_library.py)**

**8. Старт функции**
Функция `search_facebook_ads` инициализирует переменные и логику поиска.

**9. Вызов сервиса данных**
Функция обращается к внешнему модулю для получения сырых данных:
`ads = services.scrapecreators_service.search_ads_by_keyword(...)`.
*Управление передается в файл `services/scrapecreators_service.py`.*

---

### ЭТАП 4: Получение данных из Интернета
**(Файл: services/scrapecreators_service.py)**

**10. Подготовка HTTP-запроса**
Функция формирует параметры запроса (URL API, ключ авторизации, поисковая фраза).

**11. Сетевой запрос**
Выполняется `requests.get(url, params=...)`.

> **ТЕХНИЧЕСКИЙ ТЕРМИН: HTTP Request**
> Скрипт открывает TCP/IP соединение с удаленным сервером `api.scrapecreators.com`, отправляет пакет данных (запрос) и синхронно ожидает ответ.

**12. Обработка ответа**
Сервер возвращает JSON с сырыми данными. Скрипт:
1.  Получает JSON.
2.  Запускает `parse_fb_ads` для очистки данных (удаление служебных полей Facebook).
3.  Возвращает чистый список объявлений (`ads`) обратно в `mcp_library.py`.

---

### ЭТАП 5: Фильтрация и ИИ-Анализ
**(Файл: mcp_library.py)**

**13. Цикл обработки**
Запускается цикл `for ad in ads:` для последовательной проверки каждого из 20-50 полученных объявлений.

**14. Текстовая фильтрация (`filter_ad`)**
*   **Blacklist:** Проверка URL объявления по списку запрещенных доменов (Amazon, YouTube и т.д.).
*   **AI Check:** Отправка текста ("Заголовок + Тело") через API в **Google Gemini**.
*   **Решение:** Если ИИ возвращает "EXCLUDE", скрипт делает `continue` (пропускает объявление).

**15. Анализ медиа (`analyze_media_func`)**
*   **Скачивание:** `requests.get(media_url)` загружает изображение объявления в оперативную память (RAM).
*   **Vision AI:** Байты изображения отправляются в **Google Gemini Vision API**.
*   **Результат:** Нейросеть возвращает текстовое описание изображения (например: *"На фото банка с таблетками"*).

**16. Вторичная фильтрация**
Скрипт проверяет полученное *описание изображения* через ИИ. Если описание содержит запрещенные объекты (часы, одежда), объявление отбрасывается.

---

### ЭТАП 6: Сохранение данных (Persistent Storage)
**(Файл: mcp_library.py)**

**17. Сборка и Дедупликация**
Успешные объявления собираются в список. Функция `deduplicate_ads` удаляет дубликаты ссылок внутри текущей пачки.

**18. Подготовка к записи (`save_results`)**
Определяется путь к файлу: `results\ads_found_CI.json`.

**19. Чтение (I/O Read)**
Функция `load_existing_ads` пытается прочитать существующий файл с диска для проверки дубликатов.

> **ТЕХНИЧЕСКИЙ ТЕРМИН: I/O (Input/Output)**
> *Ввод/Вывод.* Операции обмена данными с накопителем (HDD/SSD). Это критический узел производительности.

**20. Запись (I/O Write)**
Скрипт объединяет новые уникальные объявления со старыми и полностью перезаписывает файл на диске с помощью `json.dump(...)`.

---

### ЭТАП 7: Возврат ответа пользователю
**(Return Path)**

**21. Возврат в диспетчер**
Функция поиска завершается и возвращает словарь результата (`{"success": True, "count": 5}`) в `manual_mcp.py`.

**22. Формирование RPC-ответа**
Скрипт упаковывает результат в структуру JSON-RPC: `{"jsonrpc": "2.0", "result": {...}, "id": 1}`.
*ID ответа (1) совпадает с ID запроса.*

**23. Сериализация**
`response_str = json.dumps(response)`.

> **ТЕХНИЧЕСКИЙ ТЕРМИН: Serialization (Сериализация)**
> Превращение объекта данных (словаря) в текстовую строку для передачи.

**24. Вывод в STDOUT**
Скрипт выполняет `sys.stdout.buffer.write(...)`.

> **ТЕХНИЧЕСКИЙ ТЕРМИН: STDOUT (Standard Output)**
> *Стандартный поток вывода.* Канал вывода данных программы. IDE перехватывает этот поток, читает сообщение и отображает его в интерфейсе чата.

**25. Финал**
Пользователь видит сообщение: *"Найдено 5 объявлений. Сохранено в файл..."*.
